"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processField = processField;
exports.initiateFormFields = initiateFormFields;
exports.updateFieldsRequirements = updateFieldsRequirements;
exports.checkboxHandler = checkboxHandler;
exports.formIsInvalid = formIsInvalid;
exports.getValues = getValues;
exports.imageUrltoImageData = imageUrltoImageData;

var _validator = _interopRequireDefault(require("validator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Process data from given field and prepare it for a form mutation.
 */
function processField(name, value, required) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var textLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var customValidationFunction = arguments.length > 5 ? arguments[5] : undefined;
  var type = options.type,
      min = options.min,
      forcedErrorMessage = options.forcedErrorMessage; // If the value is an array, remove its empty values for safety.

  var processedValue = Array.isArray(value) ? value.filter(function (item) {
    return Number.isInteger(item) || item instanceof Object || item.length;
  }) : value;
  var validation = null;
  var help = null; // VALIDATION - If any check will fail, raise error state and set help message.

  if (required && (!processedValue || processedValue.length === 0)) {
    // If the field is required and its value is empty, set an error. Otherwise
    // continue the validation.
    validation = 'error';
    help = textLabels.requiredField;
  } else if (processedValue && processedValue.length > 0) {
    // Force error message if it is present and abandon further validation.
    if (forcedErrorMessage) {
      return _defineProperty({}, name, {
        value: processedValue,
        validation: 'error',
        required: required,
        help: forcedErrorMessage
      });
    }

    switch (type) {
      case 'email':
        if (!_validator.default.isEmail(value)) {
          validation = 'error';
          help = textLabels.emailInvalid;
        }

        break;

      case 'url':
        if (!_validator.default.isURL(value)) {
          validation = 'error';
          help = textLabels.urlInvalid;
        }

        break;

      case 'tel':
        if (!value.match(/^\s*(?:\+?(\d{1,3}))?([-. (]*(\d{3})[-. )]*)?((\d{3})[-. ]*(\d{2,4})(?:[-.x ]*(\d+))?)\s*$/g)) {
          validation = 'error';
          help = textLabels.phoneInvalid;
        }

        break;

      case 'postcode':
        if (!_validator.default.isPostalCode(value, 'DE')) {
          validation = 'error';
          help = textLabels.postCodeInvalid;
        }

        break;

      case 'json':
        try {
          JSON.parse(value);
        } catch (e) {
          validation = 'error';
          help = textLabels.jsonInvalid;
        }

        break;

      default:
        // Handle custom validation function.
        if (type && customValidationFunction) {
          var error = customValidationFunction(value, type);

          if (error) {
            validation = 'error';
            help = error; // TODO: Multilanguage support for error message.
          }
        } // Minimal length option support.


        if (min && processedValue.length < min) {
          validation = 'error';
          help = textLabels.minChars.replace(':length:', min);
        }

        break;
    }
  } // If there is no error and value is not empty, indicate success state.


  if (validation !== 'error' && (processedValue && processedValue.length > 0 || _typeof(value) === 'object' && !Array.isArray(value))) {
    validation = 'success';
  }

  return _defineProperty({}, name, {
    value: processedValue,
    validation: validation,
    required: required,
    help: help
  });
}
/**
 * Generate initial form state, where all values are set to null.
 */


function initiateFormFields() {
  var fieldNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var valueUndefined; // Value undefined acts as a flag saying that field is only initiated, untouch.
  // It becomes defined after first change. It is being used by the onChange Form prop.
  // TODO: Consider adding additional property called `untouch`.

  return fieldNames.reduce(function (acc, field) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, field, {
      value: valueUndefined,
      validation: null,
      required: required.includes(field),
      help: null
    }));
  }, {});
}
/**
 * Reset valdiation states of all fields in a form.
 */


function updateFieldsRequirements(fieldsData, required) {
  var updatedFieldsData = {};
  Object.keys(fieldsData).forEach(function (key) {
    var _fieldsData$key = fieldsData[key],
        value = _fieldsData$key.value,
        help = _fieldsData$key.help;
    var isRequired = required.includes(key);
    updatedFieldsData[key] = {
      value: value,
      // If the field is not on required anymore, validation must be cleaned up.
      validation: fieldsData[key].validation === 'error' && !isRequired ? null : fieldsData[key].validation,
      help: help,
      required: isRequired
    };
  });
  return updatedFieldsData;
}
/**
 * Update single checkbox value in a list of all checkboxes.
 */


function checkboxHandler(checked, value, previousValue) {
  if (checked) {
    if (previousValue) {
      return [].concat(_toConsumableArray(previousValue), [value]);
    }

    return [value];
  }

  return previousValue.filter(function (item) {
    return item !== value;
  });
}
/**
 * Check whether whole form is filled correctly.
 */


function formIsInvalid(fieldsData) {
  var fieldKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // Check only fields of given keys, otherwise check whole form.
  var fieldsToCheck = fieldKeys.length ? fieldKeys : Object.keys(fieldsData);
  var requiredButEmpty = false;
  var hasAnyError = false;
  fieldsToCheck.forEach(function (key) {
    var _fieldsData$key2 = fieldsData[key],
        value = _fieldsData$key2.value,
        validation = _fieldsData$key2.validation,
        required = _fieldsData$key2.required;

    if (required && (typeof value === 'undefined' || typeof value === 'string' && value === '' || Array.isArray(value) && value.length === 0 || _typeof(value) === 'object' && !Array.isArray(value) && (value === null || !Object.keys(value).length))) {
      requiredButEmpty = true;
    }

    if (validation === 'error') {
      hasAnyError = true;
    }
  });
  return requiredButEmpty || hasAnyError;
}
/**
 * Get values from all fields and organize them into API friendly format.
 */


function getValues(fieldsData) {
  var values = {};
  Object.keys(fieldsData).forEach(function (key) {
    values[key] = fieldsData[key].value;
  });
  return values;
}
/**
 * Convert image url to image data format that is compatible with image upload
 * input.
 */


function imageUrltoImageData(imageUrl) {
  if (imageUrl) {
    return {
      name: imageUrl.split('/').pop(),
      data: imageUrl,
      type: 'image'
    };
  }

  return null;
}